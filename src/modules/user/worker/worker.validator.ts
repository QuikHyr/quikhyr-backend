import { AutoGeneratedFieldError } from "../../../errors";
import {
  BooleanFieldError,
  NumberFieldError,
  RequiredFieldError,
  StringFieldError,
  UnsupportedFieldError,
} from "../../../errors";
import { Worker, WorkerBasicInfo } from "./worker.type";

type ValidationFunction = (
  field: keyof Worker | keyof WorkerBasicInfo,
  value: any
) => void;

const requiredFields: (keyof Worker)[] = [
  "id",
  "fcmToken",
  "name",
  "avatar",
  "email",
  "phone",
  "gender",
  "location",
  "pincode",
  "summary",
  "available",
  "isVerified",
  "isActive",
  "serviceIds",
  "subserviceIds",
];

const optionalFields: (keyof Worker)[] = ["age"];

const autoGeneratedFields: (keyof Worker)[] = [
  "totalRatings",
  "rating",
  "locationName",
  "timestamps",
];

const supportedFields: (keyof Worker)[] = [
  ...requiredFields,
  ...optionalFields,
  ...autoGeneratedFields,
];

const basicInfoRequiredFields: (keyof WorkerBasicInfo)[] = [
  "name",
  "avatar",
  "pincode",
  "isVerified",
  "rating",
];

const basicInfoOptionalFields: (keyof WorkerBasicInfo)[] = ["subserviceName"];

const basicInfoSupportedFields: (keyof WorkerBasicInfo)[] = [
  ...basicInfoRequiredFields,
  ...basicInfoOptionalFields,
];

const validateTypes: ValidationFunction = (field, value) => {
  // Type validity checks
  switch (field) {
    case "id":
    case "fcmToken":
    case "name":
    case "avatar":
    case "email":
    case "phone":
    case "pincode":
    case "summary":
    case "subserviceName":
      if (typeof value !== "string") {
        throw new StringFieldError(field);
      }
      break;

    case "age":
    case "rating":
    case "totalRatings":
      if (typeof value !== "number") {
        throw new NumberFieldError(field);
      }
      break;

    case "available":
    case "isVerified":
    case "isActive":
      if (typeof value !== "boolean") {
        throw new BooleanFieldError(field);
      }
      break;

    case "gender":
      if (!["Male", "Female", "Other", "Rather Not Say"].includes(value)) {
        throw new Error(
          `Field '${field}' must be either "Male", "Female", or "Rather Not Say".`
        );
      }
      break;

    case "location":
      if (
        typeof value !== "object" ||
        typeof value?.latitude !== "number" ||
        typeof value?.longitude !== "number"
      ) {
        throw new Error(
          `Field '${field}' must be an object with latitude and longitude as numbers.`
        );
      }
      break;

    case "serviceIds":
    case "subserviceIds":
      if (!Array.isArray(value) || !value.every((v) => typeof v === "string")) {
        throw new Error(`Field '${field}' must be a string array.`);
      }
      break;
  }
};

export const validateWorker = (workerData: Partial<Worker>): void => {
  // Check for missing required fields
  requiredFields?.forEach((field) => {
    if (
      workerData[field] === undefined ||
      workerData[field] === null ||
      workerData[field] === ""
    ) {
      throw new RequiredFieldError(field);
    }
  });

  validateWorkerUpdate(workerData);
};

export const validateWorkerUpdate = (workerData: Partial<Worker>): void => {
  Object.keys(workerData).forEach((field) => {
    // Check for unsupported fields
    if (!supportedFields.includes(field as keyof Worker)) {
      throw new UnsupportedFieldError(field);
    } else if (autoGeneratedFields.includes(field as keyof Worker)) {
      throw new AutoGeneratedFieldError(field);
    }

    validateTypes(field as keyof Worker, workerData[field as keyof Worker]);
  });
};
