import {
  AutoGeneratedFieldError,
  RequiredFieldError,
  StringFieldError,
  UnsupportedFieldError,
} from "../../errors";
import { Rating } from "./rating.type";

type ValidationFunction = (field: keyof Rating, value: any) => void;

const requiredFields: (keyof Rating)[] = [
  "clientId",
  "workerId",
  "bookingId",
  "subserviceName",
];

const optionalFields: (keyof Rating)[] = ["ratings", "overallRating"];

const autoGeneratedFields: (keyof Rating)[] = ["timestamps"];

const supportedFields: (keyof Rating)[] = [
  ...requiredFields,
  ...optionalFields,
  ...autoGeneratedFields,
];

const validateTypes: ValidationFunction = (field, value) => {
  // Type validity checks
  switch (field) {
    case "clientId":
    case "workerId":
    case "bookingId":
    case "subserviceName":
      if (typeof value !== "string") {
        throw new StringFieldError(field);
      }
      break;

    case "ratings":
      const ratings = [
        "quality",
        "efficiency",
        "reliability",
        "knowledge",
        "value",
      ];

      if (typeof value !== "object") {
        throw new Error(`Field '${field}' must be an object.`);
      }

      ratings?.every((ratingCriteria) => {
        const criteria = value[ratingCriteria];
        if (
          typeof criteria?.rating !== "number" ||
          typeof criteria?.feedback !== "string"
        ) {
          throw new Error(
            `Field '${ratingCriteria}' is required and it must be an object with rating as a number and feedback as a string.`
          );
        }
      });
      break;

    case "overallRating":
      if (typeof value !== "object") {
        throw new Error(`Field '${field}' must be an object.`);
      }
      if (
        typeof value?.rating !== "number" ||
        typeof value?.feedback !== "string"
      ) {
        throw new Error(
          `Field '${field}' must be an object with rating as a number and feedback as a string.`
        );
      }


      if (
        typeof value?.rating !== "number" ||
        typeof value?.feedback !== "string"
      ) {
        throw new Error(
          `Field '${field}' must be an object with rating as a number and feedback as a string.`
        );
      }
      break;
  }
};

export const validateRating = (ratingData: Partial<Rating>): void => {
  // Check for missing required fields
  requiredFields?.forEach((field) => {
    if (
      ratingData[field] === undefined ||
      ratingData[field] === null ||
      ratingData[field] === ""
    ) {
      throw new RequiredFieldError(field);
    }
  });

  // Check whether ratingData has either of the optional fields
  if (
    !Object.keys(ratingData).some((field) =>
      optionalFields.includes(field as keyof Rating)
    )
  ) {
    throw new Error("Either field 'ratings' or 'overallRating' is required.");
  }

  validateRatingUpdate(ratingData);
};

export const validateRatingUpdate = (ratingData: Partial<Rating>): void => {
  Object.keys(ratingData)?.forEach((field) => {
    // Check for unsupported fields
    if (!supportedFields.includes(field as keyof Rating)) {
      throw new UnsupportedFieldError(field);
    } else if (autoGeneratedFields.includes(field as keyof Rating)) {
      throw new AutoGeneratedFieldError(field);
    }

    validateTypes(field as keyof Rating, ratingData[field as keyof Rating]);
  });
};
